@login_required
def home(request):
    """
    Plant dashboard (this is now the HOME page).
    Provides:
      - KPIs: total downtime days, event count, MTTR hours, MTBF hours
      - Pareto chart: downtime by department (top N)
      - Category chart: planned vs unplanned (if filtered, shows 100% for that type)
      - Departments grid
    """
    year, year_start, year_end = _year_window_from_request(request)
    cat, cat_filter = _cat_from_request(request)
    now_ts = timezone.now()

    # Departments for the bottom grid
    departments = Department.objects.filter(is_active=True).order_by("name")

    # Base events in selected window, active equipment + active depts only
    events_qs = DowntimeEvent.objects.filter(
        equipment__is_active=True,
        equipment__department__is_active=True,
    )
    events_qs = _events_overlapping_window(base_qs=events_qs, year_start=year_start, year_end=year_end)
    events_qs = events_qs.select_related("equipment", "equipment__department")

    # Apply category filter to "primary" metrics/charts
    if cat_filter:
        events_filtered = events_qs.filter(category=cat_filter)
    else:
        events_filtered = events_qs

    # --- KPI calculations ---
    total_downtime_sec = 0.0
    event_count = 0

    for ev in events_filtered:
        total_downtime_sec += _overlap_seconds(ev, year_start, year_end, now_ts)
        event_count += 1

    kpi_total_days = round(total_downtime_sec / 86400.0, 3)

    # MTTR/MTBF on the filtered set
    win_sec = _window_seconds(year_start, year_end, now_ts)
    uptime_sec = max(0.0, win_sec - total_downtime_sec)

    mttr_hours = _safe_div(total_downtime_sec, event_count, default=0.0) / 3600.0
    mtbf_hours = _safe_div(uptime_sec, event_count, default=0.0) / 3600.0

    kpi_mttr = round(mttr_hours, 2)
    kpi_mtbf = round(mtbf_hours, 2)

    # --- Pareto: downtime by department (top N) ---
    dept_seconds = {}
    for ev in events_filtered:
        dept_id = ev.equipment.department_id
        dept_seconds[dept_id] = dept_seconds.get(dept_id, 0.0) + _overlap_seconds(ev, year_start, year_end, now_ts)

    pareto_rows = []
    for d in departments:
        sec = dept_seconds.get(d.id, 0.0)
        if sec > 0:
            pareto_rows.append((d.name, round(sec / 86400.0, 3)))

    pareto_rows.sort(key=lambda x: x[1], reverse=True)
    top_n = 10
    pareto_rows = pareto_rows[:top_n]

    pareto_labels_json = json.dumps([r[0] for r in pareto_rows])
    pareto_values_json = json.dumps([r[1] for r in pareto_rows])

    # --- Category pie (planned vs unplanned) ---
    # If a category filter is applied, show a single-slice pie at 100% for that category.
    if cat_filter:
        # Find the label for the selected category
        label = dict(DowntimeEvent.Category.choices).get(cat_filter, cat_filter)
        cat_labels_json = json.dumps([label])
        cat_values_json = json.dumps([kpi_total_days])
    else:
        # Split by category using ALL events in window (no category filter)
        sec_planned = 0.0
        sec_unplanned = 0.0

        for ev in events_qs:
            sec = _overlap_seconds(ev, year_start, year_end, now_ts)
            if ev.category == DowntimeEvent.Category.PLANNED:
                sec_planned += sec
            else:
                sec_unplanned += sec

        cat_labels_json = json.dumps([
            DowntimeEvent.Category.PLANNED.label,
            DowntimeEvent.Category.UNPLANNED.label,
        ])
        cat_values_json = json.dumps([
            round(sec_planned / 86400.0, 3),
            round(sec_unplanned / 86400.0, 3),
        ])

    return render(
        request,
        "downtime_tracker/home.html",
        {
            "year": year,
            "cat": cat,
            "cat_choices": DowntimeEvent.Category.choices,
            "departments": departments,

            # KPIs used by template
            "kpi_total_days": kpi_total_days,
            "kpi_event_count": event_count,
            "kpi_mttr": kpi_mttr,
            "kpi_mtbf": kpi_mtbf,

            # Charts used by template
            "pareto_labels_json": pareto_labels_json,
            "pareto_values_json": pareto_values_json,
            "cat_labels_json": cat_labels_json,
            "cat_values_json": cat_values_json,
        },
    )
